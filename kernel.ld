/* 링커의 진입점은 boot함수 */
ENTRY(boot)

SECTIONS {
    /* 기본 주소 */
    . = 0x80200000;
    /*
        페이지 테이블은 애플리케이션(사용자 공간)뿐만 아니라 커널에 대해서도 구성해야 한다.
        이 책에는 커널의 가상 주소가 물리적 주소와 일치하도록 커널 메모리 매핑을 구성 (즉, vaddr == paddr). 
        이렇게 하면 페이징을 활성화한 후에도 동일한 코드가 계속 실행될 수 있음
        커널에서 사용하는 시작 주소 정의
    */
    __kernel_base = .;

    /* .text.boot 섹션은 항상 시작 부분에 배치된다.  */
    .text :{
        /* 모든 파일에서 .text 섹션과 .text로 시작하는 모든 섹션을 해당 위치로 배치 */
        KEEP(*(.text.boot));
        *(.text .text.*);
    }

    /* .text, .rodata, .data, .bss 순서로 배치 */
    .rodata : ALIGN(4){
        *(.rodata .rodata.*);
    }

    .data : ALIGN(4) {
        *(.data .data.*);
    }

    /* . 기호는 현재 주소를 나타냄 (.text)와 같이 데이터가 배치되면 자동으로 증가 */
    .bss : ALIGN(4) {
        /* _bss 심볼에 현재 주소를 할당 C 언어에서 외부 문자 symbol_name을 사용하여 정의된 심볼을 참조할 수 있음 */
        __bss = .;
        *(.bss .bss.* .sbss .sbss.*);
        __bss_end = .;
    }

    /* 커널의 스택은 .bss 섹션 이후에 128KB로 세팅된다. */
    . = ALIGN(4);
    /* 현재 주소를 128 * 1024만큼 전진 ALIGN(4)는 현재 주소가 4바이트 경계로 조정되도록 한다. */
    . += 128 * 1024; /* 128KB */
    __stack_top = .;

    /*
        __free_ram과 __free_ram_end는 스택 영역 이후의 메모리 공간을 의미한다.
        해당 공간의 크기는 64MB이고 이는 임의의 값
        . = ALIGN(4096)은 4KB 경계로 정렬되기를 확실히한다.

        주소를 하드코딩하는 대신 링커 스크립트에서 이를 정의하면 링커가 커널의 정적데이터와 겹치지 않도록 위치를 결정할 수 있다. 

        x86-64의 실제 운영 체제는 부팅 시 하드웨어에서 정보를 가져와서 사용 가능한 메모리 영역을 결정함(UEFI의 GetMemoryMap)
    */
    . = ALIGN(4096);
    __free_ram = .;
    . += 64 * 1024 * 1024; /* 64MB */
    __free_ram_end = .;
}