typedef unsigned char uint8_t;
typedef unsigned int uint32_t; 
typedef uint32_t size_t;

#include "kernel.h"

extern char __bss[], __bss_end[], __stack_top[];

void *memset(void *buf, char c, size_t n){
    uint8_t *p = (uint8_t *)buf;
    while(n--){
        *p++ = c;
    }

    return buf;
}

void kernel_main(void){
    /* 일부 부트로더는 bss 섹션을 인식하여 0으로 초기화 할 수 있지만 만일을 대비 */
    memset(__bss, 0, (size_t)__bss_end - (size_t)__bss);

    for (;;);
}

/*
커널 실행은 링커 스크립트에서 진입 지점으로 지정된 부팅 함수에서 시작된다. 
이 함수에서 스택포인터(sp)는 링커 스크립트에 정의된 스택 영역의 끝 주소로 설정됨
그리고 kernel_main함수로 이동 
스택은 0을 향해 증가하므로 사용할 수록 줄어듬
즉, 스택 영역의 끝 주소(시작 주소가 아님)를 설정해야 함
 */

/*
부팅함수에는 링커 스크립트에서 함수의 위치를 제어하는 속성이 존재
OpenSBI는 진입점을 알 지 못한채 0x80200000으로 점프하기 때문에 부팅함수는 0x80200000에 배치해야 됨
*/
__attribute__((section(".text.boot")))

/*
컴파일러가 함수 본문 앞뒤에 반환 명령어와 같은 불필요한 코드를 생성하지 않도록 지시
*/
__attribute__((naked))
void boot(void){
    __asm__ __volatile__(
        "mv sp, %[stack_top]\n" // Set the stack pointer
        "j kernel_main\n" // Jump to the kernel main function
        :
        : [stack_top] "r" (__stack_top) // stack top 주소를 %[stack_top]에 넘김
    );
}